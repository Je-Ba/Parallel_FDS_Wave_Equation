import numpy as np
import sys
import pylab as plt
from matplotlib import animation, rc
from IPython.display import display, clear_output, HTML, Image


def read_user_input():
    """
    This function will read the user input from the User_input.txt file.txt.
    The varibles set in the file will be stored in the input_array array in the 
    following order:
    input_array[y_max, x_max, imax, jmax, t_max, dt_out, c] 
    """
    with open('User_input.txt') as f:
         for i in range(0, 28):
             # read in all lines
            varible = f.readline()
            # If line does not start with / put into array
            if varible[0] != "/" :
                varible = float(varible.rstrip())
                input_array.append(varible)

def read_output_by(i):
    """
    This function loops over all processes used and their output files at 
    the timestep i and combines them in a single 2D array.
    Args:
        i (int): Timestep

    Returns:
       store_output [2d np.array]: 2d array which stores the entire solution at output i 
    """
    global store_output

    end_row = 0
    start_row = 0
    #loop over all MPI processes used
    for id in range(0,p):
        #the filename is different for every MPI processes and output i
        file_name = "./out/" + "output_" + str(id) + "_" + str(i) + ".txt"
        #use np to load values from the file into a 2d array
        an = np.loadtxt(file_name, float)
        #place the loaded 2d array into the right spot in the global array
        #this array is populated with the solution from every MPI process
        end_row += an.shape[0]
        store_output[start_row:end_row, :] = np.flipud(an)
        start_row += an.shape[0]
    
    return store_output


#check if user has given an command-line argument
if len(sys.argv) != 2:
    print("\nPlease provide number of processes used in siumulation as command line argument like\n")
    print("python post_processor.py 4\n")



input_array = []       #store User_input.txt data
p = int(sys.argv[1])   #store user command-line input
i = 0

#read User_input.txt data
read_user_input()
#find number of output files generated by code (t_max/ dt_out)
nr_output_files = int(input_array[4]/input_array[5])
#set up 2d array of correct size
store_output = np.zeros((int(input_array[2]), int(input_array[3])))


def animate(i):
    """
    Function is used for animating the output using animation.FuncAnimation
    """
    #create new set of data
    print(f"{i + 1}/{nr_output_files}")
    data = np.flipud(read_output_by(i))
 
    return data


frames = [] # array for saving the 2d images



fig = plt.figure(figsize=(9, 9))
ax = fig.add_subplot(111)
ax.set_yticklabels([])
ax.set_xticklabels([])
for i in range(nr_output_files):
    # The animation needs different aspect ratios depending on the size of the array (imax and jmax) 
    # and domain (y_max and x_max)
    # if array size is different but domain size is the same:
    if (input_array[2] != input_array[3] and input_array[0] == input_array[1] ):
        #use aspect='auto'
        frame = ax.imshow(animate(i), vmin=-5, vmax=5, interpolation='nearest',cmap=plt.cm.jet, aspect='auto')
        #add the time as text to the left of the figure
        text = plt.text(0.02, 0.5, round(i * input_array[5],1), fontsize=14, transform=plt.gcf().transFigure)
        plt.title(f"Size of the simulation {input_array[0]} x {input_array[1]}")
        plt.xlabel("x")
        plt.ylabel("y")
        frames.append([frame, text]) 


    #if domain size is different but array size is the same:
    elif (input_array[0] != input_array[1] and input_array[2] == input_array[3]):
        #set aspect ratio to reflect the ratio of y_max/x_max
        frame = ax.imshow(animate(i), vmin=-5, vmax=5, interpolation='nearest',cmap=plt.cm.jet , aspect='auto')
        ax.set_aspect(input_array[0]/input_array[1]) 
        #add the time as text to the left of the figure
        text = plt.text(0.02, 0.5, round(i * input_array[5],1), fontsize=14, transform=plt.gcf().transFigure)
        plt.title(f"Size of the simulation {input_array[0]} x {input_array[1]}")
        plt.xlabel("x")
        plt.ylabel("y")
        frames.append([frame, text]) 

    #if domain size and array size is different:
    elif (input_array[0] != input_array[1] and input_array[2] != input_array[3]):
        #set aspect ratio to reflect the ratio of y_max/x_max and use aspect='equal'
        frame = ax.imshow(animate(i), vmin=-5, vmax=5, interpolation='nearest',cmap=plt.cm.jet , aspect='equal')
        ax.set_aspect(input_array[0]/input_array[1]) 
        text = plt.text(0.02, 0.5, round(i * input_array[5],1), fontsize=14, transform=plt.gcf().transFigure)
        plt.title(f"Size of the simulation {input_array[0]} x {input_array[1]}")
        plt.xlabel("x")
        plt.ylabel("y")
        frames.append([frame, text])


    #for other casees use
    else:
        frame = ax.imshow(animate(i), vmin=-5, vmax=5, interpolation='nearest',cmap=plt.cm.jet, aspect='equal')
        ax.set_aspect(input_array[0]/input_array[1]) 
        #add the time as text to the left of the figure
        text = plt.text(0.02, 0.5, round(i * input_array[5],1), fontsize=14, transform=plt.gcf().transFigure)
        plt.title(f"Size of the simulation {input_array[0]} x {input_array[1]}")
        plt.xlabel("x")
        plt.ylabel("y")
        frames.append([frame, text])


anim = animation.ArtistAnimation(fig, frames, interval=10, blit=True)
mp4_name = "Wave_video_" + str(input_array[0]) + "x" + str(input_array[1]) + "_" + str(input_array[4]) + "s" + ".gif"
anim.save(mp4_name, writer='ffmpeg', fps=20)
